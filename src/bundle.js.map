{"version":3,"sources":["webpack:///webpack/bootstrap 620dc3bad81640b1b973","webpack:///./src/assets/js/index.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,mDAA2C,cAAc;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;AC/DA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA,+BAA+B,4BAA4B;AAC3D;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,GAAG;;AAEH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,OAAO;AACP;AACA;;AAEA;AACA;;AAEA,MAAM;AACN;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,EAAE;AACF,CAAC","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 620dc3bad81640b1b973","\nvar app = function () {\n\t// local for self/this scoping\n\tvar self = this,\n\t\t// html from our handbars template which is passed to create the template function\n\t\tdoucheBagHtml = $('#douchebag-card-template').html();\n\n\t// will hold a reference to our initialized firebase database instsance\n\tthis.fireDb = undefined;\n\t// good ol' window reference for internal ease\n\tthis.window = $(window);\n\t// Just a reference to main content div\n\tthis.mainContent = $('#card-space');\n\t// holds our Handlebars function returned by comiling our card template.  This function can be called over and over passing an object which will be filled in using the compiled template.\n\tthis.doucheBagTemplate = Handlebars.compile(doucheBagHtml);\n\n\t// indicator whether our initial firebase call has completed or not\n\tthis.initialLoadComplete = false;\n\t// holds whether we are buffering on scroll to prevent duplicate calls\n\tthis.isCallBuffered = false;\n\n\t// Initialize Firebase\n\tthis.fireBaseConfig = {\n\t\tapiKey: \"AIzaSyDeSO3Sqx-F-m3a7bvoVBYW39UL6th9eDU\",\n\t\tauthDomain: \"dogpark-douchebags.firebaseapp.com\",\n\t\tdatabaseURL: \"https://dogpark-douchebags.firebaseio.com\",\n\t\tprojectId: \"dogpark-douchebags\",\n\t\tstorageBucket: \"dogpark-douchebags.appspot.com\",\n\t\tmessagingSenderId: \"392493477164\"\n\t};\n\n\t// utility function to get a guid\n\tthis.getGuid = function () {\n\t\tvar s4 = function () {\n\t\t\treturn Math.floor((1 + Math.random()) * 0x10000)\n\t\t\t\t.toString(16)\n\t\t\t\t.substring(1);\n\t\t};\n\n\t\t// returns random s4 results as Guid ex. 00000000-0000-0000-0000-000000000000\n\t\treturn s4() + s4() + '-' + s4() + '-' + s4() + '-' +\n\t\t\ts4() + '-' + s4() + s4() + s4();\n\t}\n\n\tthis.initControls = function () {\n\t\t// initialize modal dialog\n\t\t$('.modal').modal({\n\t\t\tready: function(){\n\t\t\t\tfunction initializeLocation() {\n\t\t\t\t\tnew google.maps.places.Autocomplete(document.getElementById('submission-location'));\n\t\t\t\t}\n\n\t\t\t\tinitializeLocation()\n\t\t\t}\n\t\t\t// dismissible: false;\n\t\t});\n\n\t\t// Add our parallax header\n\t\t$('.parallax').parallax();\n\n\t\t// initialize pickatime instances\n\t\t$('.timepicker').pickatime({\n\t\t\tdefault: 'now', // Set default time: 'now', '1:30AM', '16:30'\n\t\t\tfromnow: 0, // set default time to * milliseconds from now (using with default = 'now')\n\t\t\ttwelvehour: false, // Use AM/PM or 24-hour format\n\t\t\tdonetext: 'OK', // text for done-button\n\t\t\tcleartext: 'Clear', // text for clear-button\n\t\t\tcanceltext: 'Cancel', // Text for cancel-button\n\t\t\tautoclose: false, // automatic close timepicker\n\t\t\tampmclickable: true, // make AM PM clickable\n\t\t\taftershow: function () {} //Function for after opening timepicker\n\t\t});\n\n\t\t////Dave's auto date/time picker\n\t\t$('input[type=\"time\"][value=\"now\"]').each(function () {\n\t\t\tvar d = new Date();\n\t\t\th = d.getHours();\n\t\t\tm = d.getMinutes();\n\t\t\tif (h < 10) h = '0' + h;\n\t\t\tif (m < 10) m = '0' + m;\n\t\t\t$(this).attr({\n\t\t\t\t'value': h + ':' + m\n\t\t\t});\n\t\t});\n\n\t\t$('input[type=\"text\"][value=\"day\"]').each(function () {\n\t\t\tvar today = new Date();\n\t\t\tvar month = today.getMonth();\n\t\t\tvar date = today.getDate();\n\t\t\tvar year = today.getFullYear();\n\t\t\t$(this).attr({\n\t\t\t\t\"value\": month + \"/\" + date + \"/\" + year\n\t\t\t});\n\t\t});\n\t}\n\n\t// reverses our snapshots and then calls on each iteration passing this as object, our key, and the current item\n\tthis.reverseSnapshotEntries = function (snap, callback) {\n\t\tvar keys = [];\n\t\t// loop our keys and push to array\n\t\tfor (var val in snap) {\n\t\t\tkeys.push(val);\n\t\t}\n\t\t// now we have our keys lets loop and call passing our this context, firebase key and firebase item\n\t\tfor (var i = keys.length - 1; i >= 0; i--) {\n\t\t\t// use call\n\t\t\tcallback.call(snap, keys[i], snap[keys[i]]);\n\t\t}\n\t};\n\n\t// utility function to get the count of unique keys\n\tthis.keyCount = function (snap) {\n\t\tvar keys = [];\n\t\t// loop our keys and push to array\n\t\tfor (var val in snap) {\n\t\t\tkeys.push(val);\n\t\t}\n\t\t// return the length of keys found\n\t\treturn keys.length;\n\t};\n\n\t// random number generator..  dont't leave home without it..\n\tthis.getRandomInt = function (min, max) {\n\t\tmin = Math.ceil(min);\n\t\tmax = Math.floor(max);\n\t\treturn Math.floor(Math.random() * (max - min)) + min;\n\t};\n\n\t// adds a card to the container\n\tthis.addPoopCard = function (key, item, prepend) {\n\t\t// feed the curent item into our Handlebars doucheBagTemplate which will render the row data against our item and template. Wrapped in jquery selector in order to get a jquery object.\n\t\tvar renderedDoucheBag = $(self.doucheBagTemplate(item));\n\t\t// attach our key to the rendered jQuery card object\n\t\trenderedDoucheBag.data('key', key);\n\n\t\t// initialize the poop rating\n\t\tvar rating = item['submission-rating'];\n\t\tvar ratingArray = rating;\n\n\t\tratingSum = 0;\n\n\t\t$(ratingArray).each(function(){\n\t\t\tratingSum+= this;\n\t\t})\n\n\t\tratingAvg = ratingSum/ratingArray.length;\n\t\tratingAvg = Math.round(ratingAvg);\n\n\t\tvar poopRater = renderedDoucheBag.find('.poop-rater').poopRating(5, ratingAvg);\n\n\t\tpoopRater.on('pooped',function(event,thisValue){\n\t\t\tvar thisKey = $(this).closest('.poop-card').data('key');\n\t\t\tratingArray.push(thisValue);\n\t\t\tself.updatePoop(thisKey,ratingArray);\n\n\t\t})\n\n\t\t// handle prepend/append and render to main content\n\t\tif (prepend) {\n\t\t\tself.mainContent.prepend(renderedDoucheBag);\n\t\t} else {\n\t\t\tself.mainContent.append(renderedDoucheBag);\n\t\t}\n\n\t\tvar geocoder = new google.maps.Geocoder();\n\t\tvar mapContainer = renderedDoucheBag.find('.location-map');\n\n\t\tif (mapContainer.length > 0) {\n\t\t\tvar map = new google.maps.Map(mapContainer[0], {\n\t\t\t\tzoom: 8\n\t\t\t});\n\n\t\t\tgeocoder.geocode({\n\t\t\t\t'address': item['submission-location']\n\t\t\t}, function (results, status) {\n\t\t\t\tif (status == google.maps.GeocoderStatus.OK) {\n\t\t\t\t\t//In this case it creates a marker, but you can get the lat and lng from the location.LatLng\n\t\t\t\t\tmap.setCenter(results[0].geometry.location);\n\t\t\t\t\tvar marker = new google.maps.Marker({\n\t\t\t\t\t\tmap: map,\n\t\t\t\t\t\tposition: results[0].geometry.location\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tmapContainer.hide();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t};\n\n\tthis.updatePoop = function(key,array){\n\t\tthis.fireDb.ref(key).update({'submission-rating' : array});\n\t\tvar ratedKeys = localStorage.getItem(\"rated-keys\");\n\t\tif(!ratedKeys){\n\t\t\tvar ratedKeys = [key];\n\t\t}else{\n\t\t\tvar ratedKeys = JSON.parse(ratedKeys);\n\t\t\tratedKeys.push(key);\n\t\t}\n\t\tlocalStorage.setItem('rated-keys', JSON.stringify(ratedKeys));\n\n\t}\n\n\tthis.initFireBase = function () {\n\t\tfirebase.initializeApp(this.fireBaseConfig);\n\n\t\t// get instance of firebase and assign\n\t\tthis.fireDb = firebase.database();\n\n\t\t// show our loading indicator\n\t\t$('#loading').show();\n\n\t\t// call once on the last 5 entries to initially load the 5 most recent entries\n\t\tthis.fireDb.ref().orderByKey().limitToLast(5).once('value', function (snapshot) {\n\n\t\t\t// call our reverseSnapshotEntries function in order to iterate in reverse through the returned entries\n\t\t\tself.reverseSnapshotEntries(snapshot.val(), function (key, item) {\n\t\t\t\t// add the card\n\t\t\t\tself.addPoopCard(key, item);\n\t\t\t});\n\n\t\t\t// flag that we are initialized\n\t\t\tself.initialLoadComplete = true;\n\n\t\t\t// hide our loading indicator\n\t\t\t$('#loading').hide();\n\n\t\t\t// the page starts with class full on loading to make it initially larger.  Since the initial load is complete we do not need it this big hence remove the full class to unapply\n\t\t\t$('#loading').removeClass('full');\n\n\t\t\t// go ahead and show our main content since we have our initial data set\n\t\t\t$('#main-content').show();\n\t\t});\n\n\t\tself.fireDb.ref().on('child_added', function (item) {\n\t\t\t// check to see if initial load is complete as we do not want to add anything until after we have done our initial load.\n\t\t\tif (self.initialLoadComplete) {\n\t\t\t\t// add the card\n\t\t\t\tself.addPoopCard(item.key, item.val(), true);\n\t\t\t}\n\t\t});\n\t};\n\n\tthis.initEvents = function () {\n\n\t\t// attach our submit form\n\t\t$('#subButt').on('click', function () {\n\t\t\tevent.preventDefault();\n\n\t\t\tself.submitForm();\n\t\t\tself.getRandomInsult();\n\n\t\t});\n\n\t\t$('#btn-open-modal').on('click',function(){\n\t\t\t$('#modal1').modal('open')\n\t\t})\n\t\t// window.scroll is called every time scrolling takes place on the page\n\t\tthis.window.scroll(function () {\n\t\t\t// Get the dif against the window adding 5 for good measure\n\t\t\tif ($(document).height() - self.window.height() <= self.window.scrollTop() + 5) {\n\t\t\t\t// check to see if we are currently buffering data and waiting for a response to prevent unnecessary calls to firebase if we are within the scroll bottom margin\n\t\t\t\tif (!self.isCallBuffered) {\n\t\t\t\t\t// since this is a new call set our buffer variable to prevent additional calls while we are still waiting for a response\n\t\t\t\t\tself.isCallBuffered = true;\n\n\t\t\t\t\t// show our loading content indicator\n\t\t\t\t\t$('#loading').show();\n\n\t\t\t\t\t// snag the last poop-card key from the data element so we know where we left off\n\t\t\t\t\tvar lastKnownKey = $('#main-content .poop-card').last().data('key');\n\n\t\t\t\t\t// make a single once call to firebase asking for the last 6 from our key.  Our page size is 5 so it will be a dupe of our last card + 5 new cards\n\t\t\t\t\tself.fireDb.ref().orderByKey().endAt(lastKnownKey).limitToLast(6).once('value', function (snapshot) {\n\t\t\t\t\t\tvar records = snapshot.val();\n\t\t\t\t\t\tconsole.log(self.keyCount(records));\n\t\t\t\t\t\tif (self.keyCount(records) > 1) {\n\t\t\t\t\t\t\t// call our reverseSnapshotEntries function in order to iterate in reverse through the returned entries\n\t\t\t\t\t\t\tself.reverseSnapshotEntries(snapshot.val(), function (key, item) {\n\t\t\t\t\t\t\t\t// check to see whether the current key is equal to our last key and ignore if so\n\t\t\t\t\t\t\t\tif (lastKnownKey !== key) {\n\t\t\t\t\t\t\t\t\t// add the card\n\t\t\t\t\t\t\t\t\tself.addPoopCard(key, item);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$('#loading').hide();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Set our buffer to false so we can load more if still scrolling\n\t\t\t\t\t\tself.isCallBuffered = false;\n\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t};\n\n\tthis.submitForm = function () {\n\t\t// check browser support for required functionality\n\t\tif (!window.File || !window.FileReader || !window.FileList || !window.Blob) {\n\t\t\talert('The File APIs are not fully supported in this browser.');\n\t\t\treturn;\n\t\t}\n\n\t\t// get our file input element instance\n\t\tinput = document.getElementById('submission-file');\n\n\t\t// do checks\n\t\tif (!input) {\n\t\t\tMaterialize.toast(\"Um, couldn't find the fileinput element.\", 3000);\n\t\t} else if (!input.files) {\n\t\t\tMaterialize.toast(\"This browser doesn't seem to support the `files` property of file inputs.\", 3000);\n\t\t} else if (!input.files[0]) {\n\t\t\tMaterialize.toast(\"Please select a file before clicking 'Submit'\", 3000);\n\t\t} else {\n\t\t\t// get the first input file in the selection array\n\t\t\tfile = input.files[0];\n\t\t\t// initialize file reader API\n\t\t\tfr = new FileReader();\n\t\t\t// onload fire receivedText function to store image in firebase\n\t\t\tfr.onload = self.receivedText;\n\t\t\t// readDataAsURL reads the local file into a Base64 string\n\t\t\tfr.readAsDataURL(file);\n\t\t}\n\t};\n\n\t// return a promise from random insult api call\n\tthis.getRandomInsult = function (categoryId, numQuestions) {\n\n\t\tvar q = $('#submission-identifier').val();\n\t\tvar queryURL = 'https://api.whatdoestrumpthink.com/api/v1/quotes/personalized?q=' + q;\n\n\t\treturn $.ajax({\n\t\t\turl: queryURL,\n\t\t\tmethod: \"GET\"\n\t\t});\n\t};\n\n\tthis.receivedText = function () {\n\t\t//**************************STORE THE IMAGE IN FIREBASE***************************************\n\t\t// Create a root reference\n\t\tvar storageRef = firebase.storage().ref();\n\n\t\t// call getGuid to get a unique Guid for storage\n\t\tvar imgGuid = self.getGuid();\n\n\t\t// Create a reference to 'image'\n\t\tvar imgRef = storageRef.child(imgGuid);\n\n\t\t// Create a reference to 'images/mountains.jpg'\n\t\tvar imgPathRef = storageRef.child('images/' + imgGuid);\n\n\t\t// not sure what is going on here?\n\t\t// While the file names are the same, the references point to different files\n\t\timgRef.name === imgPathRef.name // true\n\t\timgRef.fullPath === imgPathRef.fullPath // false\n\n\t\t// display image\n\t\tvar message = fr.result;\n\n\t\t$.when(\n\t\t\t// push our image to firebase storage\n\t\t\timgPathRef.putString(message, 'data_url'),\n\t\t\t// call to get a random insult api\n\t\t\tself.getRandomInsult()\n\t\t).then(function (firebaseResult, randomInsultResult) {\n\t\t\tvar newImgSrc = firebaseResult.metadata.downloadURLs[0],\n\t\t\t\tinsultText = randomInsultResult[0].message;\n\n\t\t\tdoSubmission(newImgSrc, insultText);\n\t\t});\n\n\t\tfunction doSubmission(imgSrc, insult) {\n\n\t\t\tvar post = {\n\t\t\t\t'submission-breed': $('#submission-breed').val(),\n\t\t\t\t'submission-location': $('#submission-location').val(),\n\t\t\t\t'submission-identifier': $('#submission-identifier').val(),\n\t\t\t\t'submission-title': $('#submission-title').val(),\n\t\t\t\t//'submission-by' : $('#submission-by').val(),\n\t\t\t\t//'submission-date-time' : $('#submission-date-time').val(),\n\t\t\t\t'submission-insult': insult,\n\t\t\t\t'submission-img': imgSrc,\n\t\t\t\t'submission-sortstamp': 0 - Date.now(),\n\t\t\t\t'submission-rating' : [3] //default rating to 3\n\t\t\t};\n\n\t\t\tif(post['submission-title'] === '') {\n\t\t\t\tMaterialize.toast('Please enter a title!', 2000);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif(post['submission-identifier'] === '') {\n\t\t\t\tMaterialize.toast('Please enter a Douche Nickname!', 2000);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif(post['submission-breed'] === '') {\n\t\t\t\tMaterialize.toast('Please enter a breed!', 2000);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif(post['submission-location'] === '') {\n\t\t\t\tMaterialize.toast('Please enter a location!', 2000);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif(post['submission-img'] === '') {\n\t\t\t\tMaterialize.toast('Please upload an image!', 2000);\n\t\t\t\treturn false;\n\t\t\t}\n\n\n\t\t\t//store submission\n\t\t\tself.fireDb.ref().push(post, function() {\n\t\t\t\t$(\"#modal1\").modal('close');\n\t\t\t\t$(\"formReset\").trigger('click');\n\t\t\t\treturn true;\n\n\t\t\t});\n\t\t}\n\t};\n\n\t// fire off all of our init functions and get the party started\n\tthis.initControls();\n\tthis.initFireBase();\n\tthis.initEvents();\n\n}\n$(document).ready(function () {\n\t//  As easy as new app()\n\tnew app();\n\t$('.modal-trigger').on('click',function(){\n\tfunction initialize() {\n\n\t\tvar input = document.getElementById('submission-location');\n\t\tvar autocomplete = new google.maps.places.Autocomplete(input);\n\t}\n\n\tgoogle.maps.event.addDomListener(window, 'load', initialize);\n\n\t})\n});\n\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/assets/js/index.js\n// module id = 0\n// module chunks = 0"],"sourceRoot":""}